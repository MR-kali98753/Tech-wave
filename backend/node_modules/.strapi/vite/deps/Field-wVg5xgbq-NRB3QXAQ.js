import "./chunk-73R2NYOL.js";
import "./chunk-7CIIRIIA.js";
import "./chunk-2BGSZGTB.js";
import "./chunk-5K2U7JOS.js";
import "./chunk-25NRC3OT.js";
import "./chunk-OCTQZQFO.js";
import "./chunk-3OLWLJP2.js";
import "./chunk-V27K7C3X.js";
import "./chunk-YRM3K46L.js";
import "./chunk-GTNLWOY7.js";
import "./chunk-EM5MQ6C2.js";
import "./chunk-O6QFUROF.js";
import "./chunk-EWZVFVFW.js";
import "./chunk-BPX4QPIQ.js";
import "./chunk-Y3S4P3KB.js";
import "./chunk-LVBC6J6D.js";
import "./chunk-5XOCWHHU.js";
import "./chunk-ZESFYHFX.js";
import "./chunk-MMOBCIZG.js";
import {
  useField
} from "./chunk-YJDGMQUR.js";
import {
  useStrapiApp
} from "./chunk-SOWZ3BSQ.js";
import "./chunk-X6CNA2VM.js";
import "./chunk-2JZ35VNI.js";
import "./chunk-XW43NPUH.js";
import {
  ClassicEditor,
  getPluginConfig,
  isImageResponsive,
  prefixFileUrlWithBackendUrl
} from "./chunk-Y74SRBDY.js";
import "./chunk-2VLCTXJ6.js";
import "./chunk-M5EKOYPZ.js";
import "./chunk-EPOSSBI4.js";
import "./chunk-PRKWFI3M.js";
import "./chunk-MEXVZEU6.js";
import {
  Box,
  Field,
  Flex,
  FocusTrap,
  IconButton,
  Loader,
  Portal$1
} from "./chunk-LMV7GBLX.js";
import "./chunk-IYHTQODQ.js";
import {
  ForwardRef$3B,
  ForwardRef$45
} from "./chunk-UGDAK7KS.js";
import {
  require_jsx_runtime
} from "./chunk-QBLEIVF7.js";
import {
  dt,
  ft,
  lt
} from "./chunk-5JSVERDU.js";
import {
  require_react
} from "./chunk-BCGHH3YY.js";
import {
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/@_sh/strapi-plugin-ckeditor/dist/_chunks/Field-wVg5xgbq.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@ckeditor/ckeditor5-react/dist/index.js
var import_react = __toESM(require_react());

// node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js
function createDefer() {
  const deferred = {
    resolve: null,
    promise: null
  };
  deferred.promise = new Promise((resolve) => {
    deferred.resolve = resolve;
  });
  return deferred;
}
function once(fn) {
  let lastResult = null;
  return (...args) => {
    if (!lastResult) {
      lastResult = {
        current: fn(...args)
      };
    }
    return lastResult.current;
  };
}
var HEX_NUMBERS = new Array(256).fill("").map((_, index) => ("0" + index.toString(16)).slice(-2));
function uid() {
  const [r1, r2, r3, r4] = crypto.getRandomValues(new Uint32Array(4));
  return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
}
function appendExtraPluginsToEditorConfig(config, plugins) {
  const extraPlugins = config.extraPlugins || [];
  return {
    ...config,
    extraPlugins: [
      ...extraPlugins,
      ...plugins.filter((item) => !extraPlugins.includes(item))
    ]
  };
}
function isSemanticVersion(version) {
  return !!version && /^\d+\.\d+\.\d+/.test(version);
}
function isCKCdnTestingVersion(version) {
  if (!version) {
    return false;
  }
  return ["nightly", "alpha", "internal", "nightly-", "staging"].some((testVersion) => version.includes(testVersion));
}
function isCKCdnVersion(version) {
  return isSemanticVersion(version) || isCKCdnTestingVersion(version);
}
function destructureSemanticVersion(version) {
  if (!isSemanticVersion(version)) {
    throw new Error(`Invalid semantic version: ${version || "<blank>"}.`);
  }
  const [major, minor, patch] = version.split(".");
  return {
    major: Number.parseInt(major, 10),
    minor: Number.parseInt(minor, 10),
    patch: Number.parseInt(patch, 10)
  };
}
function getLicenseVersionFromEditorVersion(version) {
  if (isCKCdnTestingVersion(version)) {
    return 3;
  }
  const { major } = destructureSemanticVersion(version);
  switch (true) {
    case major >= 44:
      return 3;
    case major >= 38:
      return 2;
    default:
      return 1;
  }
}
function getCKBaseBundleInstallationInfo() {
  const { CKEDITOR_VERSION, CKEDITOR } = window;
  if (!isCKCdnVersion(CKEDITOR_VERSION)) {
    return null;
  }
  return {
    source: CKEDITOR ? "cdn" : "npm",
    version: CKEDITOR_VERSION
  };
}
function getSupportedLicenseVersionInstallationInfo() {
  const installationInfo = getCKBaseBundleInstallationInfo();
  if (!installationInfo) {
    return null;
  }
  return getLicenseVersionFromEditorVersion(installationInfo.version);
}
function isCKEditorFreeLicense(licenseKey, licenseVersion) {
  licenseVersion || (licenseVersion = getSupportedLicenseVersionInstallationInfo() || void 0);
  switch (licenseVersion) {
    case 1:
    case 2:
      return licenseKey === void 0;
    case 3:
      return licenseKey === "GPL";
    default: {
      return false;
    }
  }
}
function createIntegrationUsageDataPlugin(integrationName, usageData) {
  return function IntegrationUsageDataPlugin(editor) {
    if (isCKEditorFreeLicense(editor.config.get("licenseKey"))) {
      return;
    }
    editor.on("collectUsageData", (source, { setUsageData }) => {
      setUsageData(`integration.${integrationName}`, usageData);
    });
  };
}

// node_modules/@ckeditor/ckeditor5-react/dist/index.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _LifeCycleElementSemaphore = class _LifeCycleElementSemaphore2 {
  constructor(element, lifecycle) {
    __publicField(this, "_lifecycle");
    __publicField(this, "_element");
    __publicField(this, "_releaseLock", null);
    __publicField(this, "_value", null);
    __publicField(this, "_afterMountCallbacks", []);
    __publicField(this, "_state", {
      destroyedBeforeInitialization: false,
      mountingInProgress: null
    });
    __publicField(this, "release", once(() => {
      const { _releaseLock, _state, _element, _lifecycle } = this;
      if (_state.mountingInProgress) {
        _state.mountingInProgress.then(() => _lifecycle.unmount({
          element: _element,
          // Mount result might be overridden by watchdog during restart so use instance variable.
          mountResult: this.value
        })).catch((error) => {
          console.error("Semaphore unmounting error:", error);
        }).then(_releaseLock.resolve).then(() => {
          this._value = null;
        });
      } else {
        _state.destroyedBeforeInitialization = true;
        _releaseLock.resolve();
      }
    }));
    this._element = element;
    this._lifecycle = lifecycle;
    this._lock();
  }
  /**
   * Getter for {@link #_value}.
   */
  get value() {
    return this._value;
  }
  /**
   * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.
   * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it
   * with a different one.
   */
  unsafeSetValue(value) {
    this._value = value;
    this._afterMountCallbacks.forEach((callback) => callback(value));
    this._afterMountCallbacks = [];
  }
  /**
   * This registers a callback that will be triggered after the editor has been successfully mounted.
   *
   * 	* If the editor is already mounted, the callback will be executed immediately.
   *	* If the editor is in the process of mounting, the callback will be executed upon successful mounting.
  * 	* If the editor is never mounted, the passed callback will not be executed.
  * 	* If an exception is thrown within the callback, it will be re-thrown in the semaphore.
  */
  runAfterMount(callback) {
    const { _value, _afterMountCallbacks } = this;
    if (_value) {
      callback(_value);
    } else {
      _afterMountCallbacks.push(callback);
    }
  }
  /**
   * This method is used to inform other components that the {@link #_element} will be used by the editor,
   * which is initialized by the {@link #_lifecycle} methods.
   *
   * 	* If an editor is already present on the provided element, the initialization of the current one
   * 	  will be postponed until the previous one is destroyed.
   *
   * 	* If the element is empty and does not have an editor attached to it, the currently locked editor will
   * 	  be mounted immediately.
   *
   * After the successful initialization of the editor and the assignment of the {@link #_value} member,
   * the `onReady` lifecycle method is called.
   *
   * *Important note:*
   *
   * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because
   * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.
   */
  _lock() {
    const { _semaphores } = _LifeCycleElementSemaphore2;
    const { _state, _element, _lifecycle } = this;
    const prevElementSemaphore = _semaphores.get(_element) || Promise.resolve(null);
    const releaseLock = createDefer();
    this._releaseLock = releaseLock;
    const newElementSemaphore = prevElementSemaphore.then(() => {
      if (_state.destroyedBeforeInitialization) {
        return Promise.resolve(void 0);
      }
      _state.mountingInProgress = _lifecycle.mount().then((mountResult) => {
        if (mountResult) {
          this.unsafeSetValue(mountResult);
        }
        return mountResult;
      });
      return _state.mountingInProgress;
    }).then(async (mountResult) => {
      if (mountResult && _lifecycle.afterMount) {
        await _lifecycle.afterMount({
          element: _element,
          mountResult
        });
      }
    }).then(() => releaseLock.promise).catch((error) => {
      console.error("Semaphore mounting error:", error);
    }).then(() => {
      if (_semaphores.get(_element) === newElementSemaphore) {
        _semaphores.delete(_element);
      }
    });
    _semaphores.set(_element, newElementSemaphore);
  }
};
__publicField(_LifeCycleElementSemaphore, "_semaphores", /* @__PURE__ */ new Map());
var LifeCycleElementSemaphore = _LifeCycleElementSemaphore;
var ReactContextMetadataKey = "$__CKEditorReactContextMetadata";
function withCKEditorReactContextMetadata(metadata, config) {
  return {
    ...config,
    [ReactContextMetadataKey]: metadata
  };
}
var ContextWatchdogContext = import_react.default.createContext(null);
var isContextWatchdogValue = (obj) => !!obj && typeof obj === "object" && "status" in obj && ["initializing", "initialized", "error"].includes(obj.status);
var isContextWatchdogValueWithStatus = (status) => (obj) => isContextWatchdogValue(obj) && obj.status === status;
var isContextWatchdogInitializing = isContextWatchdogValueWithStatus("initializing");
var isContextWatchdogReadyToUse = (obj) => isContextWatchdogValueWithStatus("initialized")(obj) && obj.watchdog.state === "ready";
var ReactIntegrationUsageDataPlugin = createIntegrationUsageDataPlugin(
  "react",
  {
    version: "9.5.0",
    frameworkVersion: import_react.default.version
  }
);
function appendAllIntegrationPluginsToConfig(editorConfig) {
  if (isCKEditorFreeLicense(editorConfig.licenseKey)) {
    return editorConfig;
  }
  return appendExtraPluginsToEditorConfig(editorConfig, [
    /**
     * This part of the code is not executed in open-source implementations using a GPL key.
     * It only runs when a specific license key is provided. If you are uncertain whether
     * this applies to your installation, please contact our support team.
     */
    ReactIntegrationUsageDataPlugin
  ]);
}
var REACT_INTEGRATION_READ_ONLY_LOCK_ID$1 = "Lock from React integration (@ckeditor/ckeditor5-react)";
var CKEditor = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    __publicField(this, "domContainer", import_react.default.createRef());
    __publicField(this, "editorSemaphore", null);
    this._checkVersion();
  }
  /**
   * Checks if the CKEditor version used in the application is compatible with the component.
   */
  _checkVersion() {
    const { CKEDITOR_VERSION } = window;
    if (!CKEDITOR_VERSION) {
      return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
    }
    const [major] = CKEDITOR_VERSION.split(".").map(Number);
    if (major >= 42 || CKEDITOR_VERSION.startsWith("0.0.0")) {
      return;
    }
    console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.");
  }
  get _semaphoreValue() {
    const { editorSemaphore } = this;
    return editorSemaphore ? editorSemaphore.value : null;
  }
  /**
   * An watchdog instance.
   */
  get watchdog() {
    const { _semaphoreValue } = this;
    return _semaphoreValue ? _semaphoreValue.watchdog : null;
  }
  /**
   * An editor instance.
   */
  get editor() {
    const { _semaphoreValue } = this;
    return _semaphoreValue ? _semaphoreValue.instance : null;
  }
  /**
   * The CKEditor component should not be updated by React itself.
   * However, if the component identifier changes, the whole structure should be created once again.
   */
  shouldComponentUpdate(nextProps) {
    const { props, editorSemaphore } = this;
    if (nextProps.id !== props.id) {
      return true;
    }
    if (nextProps.disableWatchdog !== props.disableWatchdog) {
      return true;
    }
    if (editorSemaphore) {
      editorSemaphore.runAfterMount(({ instance }) => {
        if (this._shouldUpdateEditorData(props, nextProps, instance)) {
          instance.data.set(nextProps.data);
        }
      });
      if ("disabled" in nextProps) {
        editorSemaphore.runAfterMount(({ instance }) => {
          if (nextProps.disabled) {
            instance.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);
          } else {
            instance.disableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);
          }
        });
      }
    }
    return false;
  }
  /**
   * Initialize the editor when the component is mounted.
   */
  componentDidMount() {
    if (!isContextWatchdogInitializing(this.context)) {
      this._initLifeCycleSemaphore();
    }
  }
  /**
   * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.
   */
  componentDidUpdate() {
    if (!isContextWatchdogInitializing(this.context)) {
      this._initLifeCycleSemaphore();
    }
  }
  /**
   * Destroy the editor before unmounting the component.
   */
  componentWillUnmount() {
    this._unlockLifeCycleSemaphore();
  }
  /**
   * Async destroy attached editor and unlock element semaphore.
   */
  _unlockLifeCycleSemaphore() {
    if (this.editorSemaphore) {
      this.editorSemaphore.release();
      this.editorSemaphore = null;
    }
  }
  /**
   * Unlocks previous editor semaphore and creates new one..
   */
  _initLifeCycleSemaphore() {
    this._unlockLifeCycleSemaphore();
    this.editorSemaphore = new LifeCycleElementSemaphore(this.domContainer.current, {
      mount: async () => this._initializeEditor(),
      afterMount: ({ mountResult }) => {
        const { onReady } = this.props;
        if (onReady && this.domContainer.current !== null) {
          onReady(mountResult.instance);
        }
      },
      unmount: async ({ element, mountResult }) => {
        const { onAfterDestroy } = this.props;
        try {
          await this._destroyEditor(mountResult);
          element.innerHTML = "";
        } finally {
          if (onAfterDestroy) {
            onAfterDestroy(mountResult.instance);
          }
        }
      }
    });
  }
  /**
   * Render a <div> element which will be replaced by CKEditor.
   */
  render() {
    return import_react.default.createElement("div", { ref: this.domContainer });
  }
  /**
   * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.
   */
  async _initializeEditor() {
    if (this.props.disableWatchdog) {
      const instance = await this._createEditor(this.domContainer.current, this._getConfig());
      return {
        instance,
        watchdog: null
      };
    }
    const watchdog = (() => {
      if (isContextWatchdogReadyToUse(this.context)) {
        return new EditorWatchdogAdapter(this.context.watchdog);
      }
      return new this.props.editor.EditorWatchdog(this.props.editor, this.props.watchdogConfig);
    })();
    const totalRestartsRef = {
      current: 0
    };
    watchdog.setCreator(async (el, config) => {
      var _a;
      const { editorSemaphore } = this;
      const { onAfterDestroy } = this.props;
      if (totalRestartsRef.current > 0 && onAfterDestroy && ((_a = editorSemaphore == null ? void 0 : editorSemaphore.value) == null ? void 0 : _a.instance)) {
        onAfterDestroy(editorSemaphore.value.instance);
      }
      const instance = await this._createEditor(el, config);
      if (editorSemaphore && totalRestartsRef.current > 0) {
        editorSemaphore.unsafeSetValue({
          instance,
          watchdog
        });
        setTimeout(() => {
          if (this.props.onReady) {
            this.props.onReady(watchdog.editor);
          }
        });
      }
      totalRestartsRef.current++;
      return instance;
    });
    watchdog.on("error", (_, { error, causesRestart }) => {
      const onError = this.props.onError || console.error;
      onError(error, { phase: "runtime", willEditorRestart: causesRestart });
    });
    await watchdog.create(this.domContainer.current, this._getConfig()).catch((error) => {
      const onError = this.props.onError || console.error;
      onError(error, { phase: "initialization", willEditorRestart: false });
    });
    return {
      watchdog,
      instance: watchdog.editor
    };
  }
  /**
   * Creates an editor from the element and configuration.
   *
   * @param element The source element.
   * @param config CKEditor 5 editor configuration.
   */
  _createEditor(element, config) {
    const { contextItemMetadata } = this.props;
    if (contextItemMetadata) {
      config = withCKEditorReactContextMetadata(contextItemMetadata, config);
    }
    return this.props.editor.create(
      element,
      appendAllIntegrationPluginsToConfig(config)
    ).then((editor) => {
      if ("disabled" in this.props) {
        if (this.props.disabled) {
          editor.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);
        }
      }
      const modelDocument = editor.model.document;
      const viewDocument = editor.editing.view.document;
      modelDocument.on("change:data", (event) => {
        if (this.props.onChange) {
          this.props.onChange(event, editor);
        }
      });
      viewDocument.on("focus", (event) => {
        if (this.props.onFocus) {
          this.props.onFocus(event, editor);
        }
      });
      viewDocument.on("blur", (event) => {
        if (this.props.onBlur) {
          this.props.onBlur(event, editor);
        }
      });
      return editor;
    });
  }
  /**
   * Destroys the editor by destroying the watchdog.
   */
  async _destroyEditor(initializeResult) {
    const { watchdog, instance } = initializeResult;
    return new Promise((resolve, reject) => {
      setTimeout(async () => {
        try {
          if (watchdog) {
            await watchdog.destroy();
            return resolve();
          }
          if (instance) {
            await instance.destroy();
            return resolve();
          }
          resolve();
        } catch (e) {
          console.error(e);
          reject(e);
        }
      });
    });
  }
  /**
   * Returns true when the editor should be updated.
   *
   * @param prevProps Previous react's properties.
   * @param nextProps React's properties.
   * @param editor Current editor instance.
   */
  _shouldUpdateEditorData(prevProps, nextProps, editor) {
    if (prevProps.data === nextProps.data) {
      return false;
    }
    if (editor.data.get() === nextProps.data) {
      return false;
    }
    return true;
  }
  /**
   * Returns the editor configuration.
   */
  _getConfig() {
    const config = this.props.config || {};
    if (this.props.data && config.initialData) {
      console.warn(
        "Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified."
      );
    }
    return {
      ...config,
      initialData: config.initialData || this.props.data || ""
    };
  }
};
__publicField(CKEditor, "contextType", ContextWatchdogContext);
var EditorWatchdogAdapter = class {
  /**
   * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.
   */
  constructor(contextWatchdog) {
    __publicField(this, "_contextWatchdog");
    __publicField(this, "_id");
    __publicField(this, "_creator");
    this._contextWatchdog = contextWatchdog;
    this._id = uid();
  }
  /**
   *  @param creator A watchdog's editor creator function.
   */
  setCreator(creator) {
    this._creator = creator;
  }
  /**
   * Adds an editor configuration to the context watchdog registry. Creates an instance of it.
   *
   * @param sourceElementOrData A source element or data for the new editor.
   * @param config CKEditor 5 editor config.
   */
  create(sourceElementOrData, config) {
    return this._contextWatchdog.add({
      sourceElementOrData,
      config,
      creator: this._creator,
      id: this._id,
      type: "editor"
    });
  }
  /**
   * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.
   * Currently works only for the `error` event.
   */
  on(_, callback) {
    this._contextWatchdog.on("itemError", (_2, { itemId, error }) => {
      if (itemId === this._id) {
        callback(null, { error, causesRestart: void 0 });
      }
    });
  }
  destroy() {
    if (this._contextWatchdog.state === "ready") {
      return this._contextWatchdog.remove(this._id);
    }
    return Promise.resolve();
  }
  /**
   * An editor instance.
   */
  get editor() {
    return this._contextWatchdog.getItem(this._id);
  }
};
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var EditorEditable = (0, import_react.memo)((0, import_react.forwardRef)(({ id, semaphore, rootName }, ref) => {
  const innerRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    let editable;
    let editor;
    semaphore.runAfterMount(({ instance }) => {
      if (!innerRef.current) {
        return;
      }
      editor = instance;
      const { ui, model } = editor;
      const root = model.document.getRoot(rootName);
      if (root && editor.ui.getEditableElement(rootName)) {
        editor.detachEditable(root);
      }
      editable = ui.view.createEditable(rootName, innerRef.current);
      ui.addEditable(editable);
      instance.editing.view.forceRender();
    });
    return () => {
      if (editor && editor.state !== "destroyed" && innerRef.current) {
        const root = editor.model.document.getRoot(rootName);
        if (root) {
          editor.detachEditable(root);
        }
      }
    };
  }, [semaphore.revision]);
  return import_react.default.createElement(
    "div",
    {
      key: semaphore.revision,
      id,
      ref: mergeRefs(ref, innerRef)
    }
  );
}));
EditorEditable.displayName = "EditorEditable";
var EditorToolbarWrapper = (0, import_react.forwardRef)(({ editor }, ref) => {
  const toolbarRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    const toolbarContainer = toolbarRef.current;
    if (!editor || !toolbarContainer) {
      return void 0;
    }
    const element = editor.ui.view.toolbar.element;
    toolbarContainer.appendChild(element);
    return () => {
      if (toolbarContainer.contains(element)) {
        toolbarContainer.removeChild(element);
      }
    };
  }, [editor && editor.id]);
  return import_react.default.createElement("div", { ref: mergeRefs(toolbarRef, ref) });
});
EditorToolbarWrapper.displayName = "EditorToolbarWrapper";

// node_modules/@_sh/strapi-plugin-ckeditor/dist/_chunks/Field-wVg5xgbq.mjs
import "D:/vs code/JS FrameWork(alter)/New next/nextheadlesscms/backend/node_modules/ckeditor5/dist/ckeditor5.css";
var STORAGE_KEYS = {
  TOKEN: "jwtToken",
  PREFERED_LANGUAGE: "strapi-admin-language",
  PROFILE_THEME: "STRAPI_THEME"
};
function getStoredToken() {
  const token = localStorage.getItem(STORAGE_KEYS.TOKEN) ?? sessionStorage.getItem(STORAGE_KEYS.TOKEN);
  if (typeof token === "string") {
    return JSON.parse(token);
  }
  return null;
}
function getPreferedLanguage() {
  var _a;
  const language = ((_a = localStorage.getItem(STORAGE_KEYS.PREFERED_LANGUAGE)) == null ? void 0 : _a.replace(/^"|"$/g, "")) || "en";
  return language;
}
function getProfileTheme() {
  const theme = localStorage.getItem(STORAGE_KEYS.PROFILE_THEME);
  return theme;
}
var TRANSLATIONS = {};
async function setUpLanguage(config, isFieldLocalized) {
  var _a;
  if (typeof config.language !== "object") {
    config.language = {
      ui: config.language,
      content: config.language,
      textPartLanguage: void 0
    };
  }
  (_a = config.language).ui || (_a.ui = getPreferedLanguage());
  if (isFieldLocalized) {
    config.language.content = detecti18n();
  }
  if (config.language.ui !== "en") {
    await importLang(config, config.language.ui);
  }
}
async function importLang(config, language) {
  if (TRANSLATIONS[language]) {
    config.translations = TRANSLATIONS[language];
  } else if (translationImports[language]) {
    const translation = await translationImports[language]();
    TRANSLATIONS[language] = translation.default;
    config.translations = translation.default;
  } else {
    console.warn(`No CKEditor translation found for language: ${language}`);
  }
}
function detecti18n() {
  const urlSearchParams = new URLSearchParams(window.location.search);
  const params = Object.fromEntries(urlSearchParams.entries());
  const i18n = params["plugins[i18n][locale]"];
  return i18n && i18n.split("-")[0];
}
var translationImports = {
  af: () => import("./af-DIAVOCZG.js"),
  ar: () => import("./ar-2KI5XJNE.js"),
  ast: () => import("./ast-YUVWTAF3.js"),
  az: () => import("./az-D3VW7D5R.js"),
  bg: () => import("./bg-7SKTZLDD.js"),
  bn: () => import("./bn-ULVB4NDU.js"),
  bs: () => import("./bs-OYLMZ7EP.js"),
  ca: () => import("./ca-BQ5V3UHI.js"),
  cs: () => import("./cs-P4D36ODP.js"),
  da: () => import("./da-EAV2LT3H.js"),
  "de-ch": () => import("./de-ch-TR2B75ZF.js"),
  de: () => import("./de-DJWGPVP7.js"),
  el: () => import("./el-GDTCILJ5.js"),
  "en-au": () => import("./en-au-3L75CIBT.js"),
  "en-gb": () => import("./en-gb-XFEORM4C.js"),
  en: () => import("./en-BNFUC3XG.js"),
  eo: () => import("./eo-UYLOQYH6.js"),
  "es-co": () => import("./es-co-2SWBUMH2.js"),
  es: () => import("./es-GNSMWR4O.js"),
  et: () => import("./et-UV7RH4L7.js"),
  eu: () => import("./eu-ZH5LIOW5.js"),
  fa: () => import("./fa-WAKOWEEM.js"),
  fi: () => import("./fi-KN4ZCTFE.js"),
  fr: () => import("./fr-HD6ERWKG.js"),
  gl: () => import("./gl-OLJDNPKK.js"),
  gu: () => import("./gu-KSLVVKHE.js"),
  he: () => import("./he-CUAK363C.js"),
  hi: () => import("./hi-KBU2YGZD.js"),
  hr: () => import("./hr-ENMI6A5J.js"),
  hu: () => import("./hu-4LF5V4FB.js"),
  hy: () => import("./hy-RB554EJJ.js"),
  id: () => import("./id-NZJ52KMJ.js"),
  it: () => import("./it-VN4ZTMFE.js"),
  ja: () => import("./ja-U67L3XDA.js"),
  jv: () => import("./jv-7SRGPW7R.js"),
  kk: () => import("./kk-WWONWWTI.js"),
  km: () => import("./km-IK5EZ2WF.js"),
  kn: () => import("./kn-2EGZLLXG.js"),
  ko: () => import("./ko-RGBHYNP7.js"),
  ku: () => import("./ku-4QS52U6E.js"),
  lt: () => import("./lt-RTXB4BUI.js"),
  lv: () => import("./lv-JBQDN65R.js"),
  ms: () => import("./ms-JHQWFYTX.js"),
  nb: () => import("./nb-UJ36EDSR.js"),
  ne: () => import("./ne-GRK3NHYW.js"),
  nl: () => import("./nl-RBNAEL2N.js"),
  no: () => import("./no-2BSAFFJ7.js"),
  oc: () => import("./oc-VEY4DWWM.js"),
  pl: () => import("./pl-QH2AQQ7W.js"),
  "pt-br": () => import("./pt-br-DWUDFRWA.js"),
  pt: () => import("./pt-PNEDPANP.js"),
  ro: () => import("./ro-KCA5UEX6.js"),
  ru: () => import("./ru-LGIOMRBV.js"),
  si: () => import("./si-PWKXGIYV.js"),
  sk: () => import("./sk-KORD32JI.js"),
  sl: () => import("./sl-RTIDBHWO.js"),
  sq: () => import("./sq-MXMV3RKU.js"),
  sr: () => import("./sr-FQIQBAYS.js"),
  "sr-latn": () => import("./sr-latn-EGDONCKD.js"),
  sv: () => import("./sv-NATYMGTE.js"),
  th: () => import("./th-QUBGNYBI.js"),
  ti: () => import("./ti-EIYMF2AH.js"),
  tk: () => import("./tk-OHFN6KU5.js"),
  tr: () => import("./tr-73RVUT6T.js"),
  tt: () => import("./tt-YLR4T7JW.js"),
  ug: () => import("./ug-MMRV4DCE.js"),
  uk: () => import("./uk-7YZ27FU6.js"),
  ur: () => import("./ur-4F6JB3Y4.js"),
  uz: () => import("./uz-M3KQ4DM4.js"),
  vi: () => import("./vi-LQ2AN7PS.js"),
  "zh-cn": () => import("./zh-cn-J62VEGL6.js"),
  zh: () => import("./zh-VC5LSCC3.js")
};
var EditorContext = (0, import_react2.createContext)(null);
function useEditorContext() {
  const context = (0, import_react2.useContext)(EditorContext);
  if (!context) {
    throw new Error("The useEditorContext hook must be used within the EditorProvider.");
  }
  return context;
}
function EditorProvider({
  name,
  disabled,
  error,
  placeholder,
  hint,
  label,
  labelAction,
  required,
  presetName,
  wordsLimit,
  charsLimit,
  children,
  isFieldLocalized
}) {
  const [preset, setPreset] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    (async () => {
      const { presets } = getPluginConfig();
      const currentPreset = clonePreset(presets[presetName]);
      await setUpLanguage(currentPreset.editorConfig, isFieldLocalized);
      if (placeholder) {
        currentPreset.editorConfig.placeholder = placeholder;
      }
      setPreset(currentPreset);
    })();
  }, [presetName, placeholder, isFieldLocalized]);
  const EditorContextValue = (0, import_react2.useMemo)(
    () => ({
      name,
      disabled,
      placeholder,
      hint,
      label,
      labelAction,
      required,
      presetName,
      preset,
      error,
      wordsLimit,
      charsLimit,
      isFieldLocalized
    }),
    [
      name,
      disabled,
      placeholder,
      hint,
      label,
      labelAction,
      required,
      presetName,
      wordsLimit,
      charsLimit,
      preset,
      error,
      isFieldLocalized
    ]
  );
  return (0, import_jsx_runtime.jsx)(EditorContext.Provider, { value: EditorContextValue, children });
}
function clonePreset(preset) {
  const clonedPreset = {
    ...preset,
    editorConfig: {
      ...preset.editorConfig
    }
  };
  Object.entries(clonedPreset.editorConfig).forEach(([key, val]) => {
    if (val && typeof val === "object" && Object.getPrototypeOf(val) === Object.prototype) {
      clonedPreset.editorConfig[key] = { ...val };
    }
  });
  return clonedPreset;
}
function MediaLib({ isOpen = false, toggle, handleChangeAssets }) {
  const components = useStrapiApp("MediaLib", (state) => state.components);
  const MediaLibraryDialog = components["media-library"];
  function handleSelectAssets(files) {
    const formattedFiles = files.map((f) => ({
      name: f.name,
      alt: f.alternativeText || f.name,
      url: prefixFileUrlWithBackendUrl(f.url),
      mime: f.mime,
      formats: f.formats,
      width: f.width,
      height: f.height
    }));
    const newElems = getNewElems(formattedFiles);
    handleChangeAssets(newElems);
  }
  function getNewElems(assets) {
    let newElems = "";
    assets.forEach(({ name, url, alt, formats, mime, width, height }) => {
      if (mime.includes("image")) {
        if (formats && isImageResponsive(formats)) {
          const set = formSrcSet(formats);
          newElems += `<img src="${url}" alt="${alt}" width="${width}" height="${height}" srcset="${set}" />`;
        } else {
          newElems += `<img src="${url}" alt="${alt}" width="${width}" height="${height}" />`;
        }
      } else if (mime.includes("video")) {
        newElems += `
            <video class="video" controls width="500px">
                <source src="${url}" type="${mime}" />
            </video>`;
      } else {
        newElems += `<a href="${url}">${name || "Open document"}</a>`;
      }
    });
    return newElems;
  }
  function formSrcSet(formats) {
    let set = "";
    const keys = Object.keys(formats).sort((a, b) => formats[a].width - formats[b].width);
    keys.forEach((k) => {
      set += `${prefixFileUrlWithBackendUrl(formats[k].url)} ${formats[k].width}w,`;
    });
    return set;
  }
  if (!isOpen) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(MediaLibraryDialog, { onClose: toggle, onSelectAssets: handleSelectAssets });
}
var MemoizedMediaLib = import_react2.default.memo(MediaLib);
function CKEReact() {
  const [mediaLibVisible, setMediaLibVisible] = (0, import_react2.useState)(false);
  const [editorInstance, setEditorInstance] = (0, import_react2.useState)(null);
  const [isWordsMax, setIsWordsMax] = (0, import_react2.useState)(false);
  const [isCharsMax, setIsCharsMax] = (0, import_react2.useState)(false);
  const { name, disabled, preset, wordsLimit, charsLimit } = useEditorContext();
  const { onChange: fieldOnChange, value: fieldValue } = useField(name);
  const wordCounterRef = (0, import_react2.useRef)(null);
  const onEditorReady = (editor) => {
    setUpPlugins(editor);
    setEditorInstance(editor);
  };
  const onEditorChange = (_e, editor) => {
    const data = editor.getData();
    fieldOnChange(name, data);
  };
  const toggleMediaLib = (0, import_react2.useCallback)(() => setMediaLibVisible((prev) => !prev), [setMediaLibVisible]);
  const handleChangeAssets = (0, import_react2.useCallback)(
    (newElems) => {
      if (!editorInstance) {
        throw new Error("The editor instance has not been initialized.");
      }
      const viewFragment = editorInstance.data.processor.toView(newElems);
      const modelFragment = editorInstance.data.toModel(viewFragment);
      editorInstance == null ? void 0 : editorInstance.model.insertContent(modelFragment);
      toggleMediaLib();
    },
    [toggleMediaLib, editorInstance]
  );
  if (!preset) {
    return null;
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(
      CKEditor,
      {
        editor: ClassicEditor,
        config: preset.editorConfig,
        disabled,
        data: fieldValue ?? "",
        onReady: onEditorReady,
        onChange: onEditorChange
      }
    ),
    (0, import_jsx_runtime.jsx)(WordCounter, { ref: wordCounterRef, $isWordsMax: isWordsMax, $isCharsMax: isCharsMax }),
    (0, import_jsx_runtime.jsx)(
      MemoizedMediaLib,
      {
        isOpen: mediaLibVisible,
        toggle: toggleMediaLib,
        handleChangeAssets
      }
    )
  ] });
  function setUpPlugins(editor) {
    const pluginsToSetup = {
      WordCount: setUpWordCount,
      ImageUploadEditing: setUpImageUploadEditing,
      StrapiMediaLib: setUpStrapiMediaLib,
      StrapiUploadAdapter: setUpStrapiUploadAdapter
    };
    Object.entries(pluginsToSetup).forEach(([pluginName, setUpFn]) => {
      if (editor.plugins.has(pluginName)) {
        try {
          setUpFn(editor);
        } catch (err) {
          console.error(`Failed to set up the ${pluginName} plugin `, err);
        }
      }
    });
  }
  function setUpWordCount(editor) {
    var _a;
    const wordCountPlugin = editor.plugins.get("WordCount");
    if (wordsLimit || charsLimit) {
      wordCountPlugin.on("update", (_e, stats) => validateInputLength(stats));
      const { words, characters } = wordCountPlugin;
      validateInputLength({ words, characters });
    }
    (_a = wordCounterRef.current) == null ? void 0 : _a.appendChild(wordCountPlugin.wordCountContainer);
  }
  function setUpImageUploadEditing(editor) {
    const imageUploadEditingPlugin = editor.plugins.get("ImageUploadEditing");
    const setAltAttribute = (_e, { data, imageElement }) => {
      editor.model.change((writer) => {
        writer.setAttribute("alt", data.alt, imageElement);
      });
    };
    imageUploadEditingPlugin.on("uploadComplete", setAltAttribute);
  }
  function setUpStrapiMediaLib(editor) {
    const strapiMediaLibPlugin = editor.plugins.get("StrapiMediaLib");
    strapiMediaLibPlugin.connect(toggleMediaLib);
  }
  function setUpStrapiUploadAdapter(editor) {
    const StrapiUploadAdapterPlugin = editor.plugins.get(
      "StrapiUploadAdapter"
    );
    const token = getStoredToken();
    const config = {
      uploadUrl: prefixFileUrlWithBackendUrl("/upload"),
      headers: { Authorization: `Bearer ${token}` }
    };
    StrapiUploadAdapterPlugin.initAdapter(config);
  }
  function validateInputLength(stats) {
    if (wordsLimit) {
      setIsWordsMax(stats.words > wordsLimit);
    }
    if (charsLimit) {
      setIsCharsMax(stats.characters > charsLimit);
    }
  }
}
var WordCounter = dt(Flex)`
  ${({ theme, $isWordsMax, $isCharsMax }) => lt`
    .ck-word-count__words {
      color: ${$isWordsMax ? theme.colors.danger600 : theme.colors.neutral400};
    }
    .ck-word-count__characters {
      color: ${$isCharsMax ? theme.colors.danger600 : theme.colors.neutral400};
    }
  `}
`;
function EditorLayout({ children }) {
  const { error, preset } = useEditorContext();
  const [isExpandedMode, setIsExpandedMode] = (0, import_react2.useState)(false);
  const handleToggleExpand = () => setIsExpandedMode(true);
  const handleOnCollapse = () => setIsExpandedMode(false);
  (0, import_react2.useEffect)(() => {
    if (isExpandedMode) {
      document.body.classList.add("lock-body-scroll");
    }
    return () => {
      document.body.classList.remove("lock-body-scroll");
    };
  }, [isExpandedMode]);
  if (isExpandedMode) {
    return (0, import_jsx_runtime.jsx)(Portal$1, { role: "dialog", "aria-modal": false, children: (0, import_jsx_runtime.jsx)(FocusTrap, { onEscape: handleOnCollapse, children: (0, import_jsx_runtime.jsx)(
      Backdrop,
      {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: 4,
        justifyContent: "center",
        onClick: handleOnCollapse,
        children: (0, import_jsx_runtime.jsx)(
          FullScreenBox,
          {
            background: "neutral100",
            hasRadius: true,
            shadow: "popupShadow",
            overflow: "hidden",
            width: "90%",
            height: "90%",
            onClick: (e) => e.stopPropagation(),
            position: "relative",
            children: (0, import_jsx_runtime.jsx)(Flex, { height: "100%", alignItems: "flex-start", direction: "column", children: (0, import_jsx_runtime.jsxs)(
              EditorWrapper,
              {
                $presetStyles: preset == null ? void 0 : preset.styles,
                $isExpanded: isExpandedMode,
                $hasError: Boolean(error),
                className: "ck-editor__expanded",
                children: [
                  children,
                  (0, import_jsx_runtime.jsx)(CollapseButton, { label: "Collapse", onClick: handleOnCollapse, children: (0, import_jsx_runtime.jsx)(ForwardRef$45, {}) })
                ]
              }
            ) })
          }
        )
      }
    ) }) });
  }
  return (0, import_jsx_runtime.jsxs)(
    EditorWrapper,
    {
      $presetStyles: preset == null ? void 0 : preset.styles,
      $isExpanded: isExpandedMode,
      $hasError: Boolean(error),
      children: [
        children,
        (0, import_jsx_runtime.jsx)(ExpandButton, { label: "Expand", onClick: handleToggleExpand, children: (0, import_jsx_runtime.jsx)(ForwardRef$3B, {}) })
      ]
    }
  );
}
var EditorWrapper = dt("div")`
  position: relative;
  width: 100%;

  ${({ $presetStyles, theme, $hasError = false, $isExpanded }) => lt`
    height: ${$isExpanded ? "100%" : "auto"};
    border-radius: ${theme.borderRadius};
    outline: none;
    box-shadow: 0;
    transition-property: border-color, box-shadow, fill;
    transition-duration: 0.2s;
    border: 1px solid ${$hasError ? theme.colors.danger600 : theme.colors.neutral200};
    border-radius: ${theme.borderRadius};

    &:focus-within {
      border: 1px solid ${$isExpanded ? theme.colors.neutral200 : theme.colors.primary600};
      border-color: ${$hasError && theme.colors.danger600};
      box-shadow: ${$hasError ? theme.colors.danger600 : theme.colors.primary600} 0px 0px 0px 2px;
    }

    ${$presetStyles}
  `}
`;
var Backdrop = dt(Flex)`
  background: ${({ theme }) => `${theme.colors.neutral800}1F`};
`;
var ExpandButton = dt(IconButton)`
  position: absolute;
  bottom: 1.4rem;
  right: 1.2rem;
  z-index: 2;
`;
var CollapseButton = dt(IconButton)`
  position: absolute;
  bottom: 2.5rem;
  right: 1.2rem;
  z-index: 2;
`;
var FullScreenBox = dt(Box)`
  max-width: var(--ck-editor-full-screen-box-max-width);
`;
var GlobalStyle = ft`
  ${({ $editortTheme, $variant }) => $editortTheme && lt`
      ${$editortTheme.common}
      ${$editortTheme[$variant]}
      ${$editortTheme.additional}
    `}
`;
var getSystemColorScheme = () => window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
function GlobalStyling() {
  const { theme } = getPluginConfig();
  const profileTheme = getProfileTheme();
  const variant = profileTheme && profileTheme !== "system" ? profileTheme : getSystemColorScheme();
  return (0, import_jsx_runtime.jsx)(GlobalStyle, { $editortTheme: theme, $variant: variant });
}
var MemoizedGlobalStyling = import_react2.default.memo(GlobalStyling);
function Editor() {
  const { name, hint, required, labelAction, label, error, preset } = useEditorContext();
  return (0, import_jsx_runtime.jsx)(Field.Root, { id: name, name, error, hint, required, children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "stretch", gap: 1, children: [
    (0, import_jsx_runtime.jsx)(Field.Label, { action: labelAction, children: label }),
    preset ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      (0, import_jsx_runtime.jsx)(MemoizedGlobalStyling, {}),
      (0, import_jsx_runtime.jsx)(EditorLayout, { children: (0, import_jsx_runtime.jsx)(CKEReact, {}) })
    ] }) : (0, import_jsx_runtime.jsx)(LoaderBox, { hasRadius: true, background: "neutral100", children: (0, import_jsx_runtime.jsx)(Loader, { children: "Loading..." }) }),
    (0, import_jsx_runtime.jsx)(Field.Hint, {}),
    (0, import_jsx_runtime.jsx)(Field.Error, {})
  ] }) });
}
var LoaderBox = dt(Box)`
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  width: 100%;
`;
function Field2({
  name,
  hint,
  error,
  placeholder,
  label,
  attribute,
  labelAction = null,
  disabled = false,
  required = false
}) {
  var _a, _b;
  const { preset, maxLengthWords, maxLengthCharacters } = attribute.options;
  const isFieldLocalized = ((_b = (_a = attribute == null ? void 0 : attribute.pluginOptions) == null ? void 0 : _a.i18n) == null ? void 0 : _b.localized) ?? false;
  return (0, import_jsx_runtime.jsx)(
    EditorProvider,
    {
      name,
      error,
      disabled,
      required,
      placeholder,
      hint,
      label,
      labelAction,
      presetName: preset,
      wordsLimit: maxLengthWords,
      charsLimit: maxLengthCharacters,
      isFieldLocalized,
      children: (0, import_jsx_runtime.jsx)(Editor, {})
    }
  );
}
function compare(oldProps, newProps) {
  return oldProps.error === newProps.error && oldProps.labelAction === newProps.labelAction;
}
var MemoizedField = import_react2.default.memo(Field2, compare);
export {
  MemoizedField as Field
};
/*! Bundled license information:

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
  (* istanbul ignore else -- @preserve *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (* istanbul ignore else -- @preserve *)
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
*/
//# sourceMappingURL=Field-wVg5xgbq-NRB3QXAQ.js.map
